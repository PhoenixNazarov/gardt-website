!(function () { function e (e, t) { for (let n = 0; n < t.length; n++) { const i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } function t (t, n, i) { return n && e(t.prototype, n), i && e(t, i), t } function n (e, t) { e.prototype = Object.create(t.prototype), e.prototype.constructor = e, i(e, t) } function i (e, t) { return (i = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e })(e, t) } function r (e, t) { (t == null || t > e.length) && (t = e.length); for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n]; return i } function a (e, t) { let n = typeof Symbol !== 'undefined' && e[Symbol.iterator] || e['@@iterator']; if (n) return (n = n.call(e)).next.bind(n); if (Array.isArray(e) || (n = (function (e, t) { if (e) { if (typeof e === 'string') return r(e, t); let n = Object.prototype.toString.call(e).slice(8, -1); return n === 'Object' && e.constructor && (n = e.constructor.name), n === 'Map' || n === 'Set' ? Array.from(e) : n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? r(e, t) : void 0 } }(e))) || t && e && typeof e.length === 'number') { n && (e = n); let i = 0; return function () { return i >= e.length ? { done: !0 } : { done: !1, value: e[i++] } } } throw new TypeError('Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.') } function o (e, t) { if (e instanceof CSSUnitValue || e instanceof CSSMathSum) return e; if (!t) return null; const n = e.trim().match(/^(-?[0-9]*\.?[0-9]*)(px|%)$/); return n ? new CSSUnitValue(n[1], n[2] == '%' ? 'percent' : n[2]) : null }!(function () { let e; const i = new WeakMap(); function r (e) { for (var t, n = [], i = 0; i < e.length; i++) n[i] = typeof (t = e[i]) === 'number' ? new CSSUnitValue(t, 'number') : t; return n } const a = (function () { function e (e, t, n, a) { i.set(this, { values: r(e), operator: t, name: n || t, delimiter: a || ', ' }) } return e.prototype.toString = function () { const e = i.get(this); return e.name + '(' + e.values.join(e.delimiter) + ')' }, t(e, [{ key: 'operator', get: function () { return i.get(this).operator } }, { key: 'values', get: function () { return i.get(this).values } }]), e }()); const o = ((e = { CSSUnitValue: (function () { function e (e, t) { i.set(this, { value: e, unit: t }) } return e.prototype.toString = function () { const e = i.get(this); return '' + e.value + (function (e) { switch (e) { case 'percent':return '%'; case 'number':return ''; default:return e.toLowerCase() } }(e.unit)) }, t(e, [{ key: 'value', get: function () { return i.get(this).value }, set: function (e) { i.get(this).value = e } }, { key: 'unit', get: function () { return i.get(this).unit } }]), e }()), CSSKeywordValue: (function () { function e (e) { this.value = e } return e.prototype.toString = function () { return this.value.toString() }, e }()), CSSMathSum: (function (e) { function t (t) { return e.call(this, arguments, 'sum', 'calc', ' + ') || this } return n(t, e), t }(a)), CSSMathProduct: (function (e) { function t (t) { return e.call(this, arguments, 'product', 'calc', ' * ') || this } return n(t, e), t }(a)), CSSMathNegate: (function (e) { function t (t) { return e.call(this, [arguments[0]], 'negate', '-') || this } return n(t, e), t }(a)) }).CSSMathNegate = (function (e) { function t (t) { return e.call(this, [1, arguments[0]], 'invert', 'calc', ' / ') || this } return n(t, e), t }(a)), e.CSSMathMax = (function (e) { function t () { return e.call(this, arguments, 'max') || this } return n(t, e), t }(a)), e.CSSMathMin = (function (e) { function t () { return e.call(this, arguments, 'min') || this } return n(t, e), t }(a)), e); if (!window.CSS && !Reflect.defineProperty(window, 'CSS', { value: {} })) throw Error('Error installing CSSOM support'); for (const l in window.CSSUnitValue || ['number', 'percent', 'em', 'ex', 'px', 'cm', 'mm', 'in', 'pt', 'pc', 'Q', 'vw', 'vh', 'vmin', 'vmax', 'rems', 'ch', 'deg', 'rad', 'grad', 'turn', 'ms', 's', 'Hz', 'kHz', 'dppx', 'dpi', 'dpcm', 'fr'].forEach(function (e) { if (!Reflect.defineProperty(CSS, e, { value: function (t) { return new CSSUnitValue(t, e) } })) throw Error('Error installing CSS.' + e) }), o) if (!(l in window) && !Reflect.defineProperty(window, l, { value: o[l] })) throw Error('Error installing CSSOM support for ' + l) }()); const l = new CSSKeywordValue('auto'); const u = new WeakMap(); const s = []; function c (e) { return e === document.scrollingElement ? document : e } function m (e) { const t = u.get(e).animations; if (t.length !== 0) for (let n = e.currentTime, i = 0; i < t.length; i++) t[i].tickAnimation(n) } function f (e, t) { const n = getComputedStyle(e).writingMode == 'horizontal-tb'; let i = e.scrollTop; return (t == 'horizontal' || t == 'inline' && n || t == 'block' && !n) && (i = Math.abs(e.scrollLeft)), i } function h (e, t) { if (e instanceof CSSUnitValue) { if (e.unit == 'percent') return e.value * t / 100; if (e.unit == 'px') return e.value; throw TypeError('Unhandled unit type ' + e.unit) } if (e instanceof CSSMathSum) { for (var n, i = 0, r = a(e.values); !(n = r()).done;) i += h(n.value, t); return i } throw TypeError('Unsupported value type: ' + typeof e) } function p (e, t, n, i, r) { if (r) return r(t, n, i, e.value == 0 ? 'start' : 'end'); n === 'block' ? n = 'vertical' : n === 'inline' && (n = 'horizontal'); const a = n === 'vertical' ? t.scrollHeight - t.clientHeight : t.scrollWidth - t.clientWidth; return h(o(i === l ? e : i), a) } function d (e, t, n, i) { const r = []; let a = !0; n.length == 0 ? (r.push(p(new CSSUnitValue(0, 'percent'), e, t, l)), a = !1, r.push(p(new CSSUnitValue(100, 'percent'), e, t, l))) : n.length == 1 && (r.push(p(new CSSUnitValue(0, 'percent'), e, t, l)), a = !1); for (let o = 0; o < n.length; o++) { const u = p(a ? new CSSUnitValue(0, 'percent') : new CSSUnitValue(100, 'percent'), e, t, n[o], i[o]); if (u === null) return []; r.push(u), a = !1 } return r } function g (e, t) { for (let n = u.get(e).animations, i = 0; i < n.length; i++) n[i].animation == t && n.splice(i, 1) } function v (e, t, n) { for (var i = u.get(e).animations, r = 0; r < i.length; r++) if (i[r].animation == t) return; i.push({ animation: t, tickAnimation: n }), m(e) } const y = (function () { function e (e) { u.set(this, { scrollSource: null, orientation: 'block', scrollOffsets: [], animations: [], scrollOffsetFns: [] }), this.scrollSource = e && void 0 !== e.scrollSource ? e.scrollSource : document.scrollingElement, this.orientation = e && e.orientation || 'block', this.scrollOffsets = e && void 0 !== e.scrollOffsets ? e.scrollOffsets : [] } return t(e, [{ key: 'scrollSource', get: function () { return u.get(this).scrollSource }, set: function (e) { const t = this; const fixl = function () { return m(t) }; document._fixScrollListeners.push(fixl); this.scrollSource && c(this.scrollSource).removeEventListener('scroll', function () { return m(t) }), u.get(this).scrollSource = e, e && c(e).addEventListener('scroll', fixl), m(this) } }, { key: 'orientation', get: function () { return u.get(this).orientation }, set: function (e) { if (['block', 'inline', 'horizontal', 'vertical'].indexOf(e) === -1) throw TypeError('Invalid orientation'); u.get(this).orientation = e, m(this) } }, { key: 'scrollOffsets', get: function () { return u.get(this).scrollOffsets }, set: function (e) { for (var t, n = [], i = [], r = a(e); !(t = r()).done;) { let c = t.value; let f = null; let h = void 0; c == 'auto' && (c = l); for (let p = 0; p < s.length; p++) { const d = s[p].parse(c); if (void 0 !== d) { h = d, f = s[p].evaluate; break } } if (!f) { if (c != l) { const g = o(c); if (!g || g instanceof CSSUnitValue && g.unit == 'number') throw TypeError('Invalid scrollOffsets entry.') }h = c }n.push(h), i.push(f) } if (n.length == 1 && n[0] == l) throw TypeError('Invalid scrollOffsets value.'); const v = u.get(this); v.scrollOffsets = n, v.scrollOffsetFns = i, m(this) } }, { key: 'duration', get: function () { return CSS.percent(100) } }, { key: 'phase', get: function () { if (!this.scrollSource) return 'inactive'; const e = getComputedStyle(this.scrollSource); if (e.display == 'none') return 'inactive'; if (this.scrollSource != document.scrollingElement && (e.overflow == 'visible' || e.overflow == 'clip')) return 'inactive'; const t = d(this.scrollSource, this.orientation, this.scrollOffsets, u.get(this).scrollOffsetFns); if (t.length == 0) return 'inactive'; const n = p(new CSSUnitValue(100, 'percent'), this.scrollSource, this.orientation, new CSSUnitValue(100, 'percent'), null); const i = t[0]; const r = t[t.length - 1]; const a = f(this.scrollSource, this.orientation); return a < i ? 'before' : a >= r && r < n ? 'after' : 'active' } }, { key: 'currentTime', get: function () { if (!this.scrollSource) return null; if (this.phase == 'inactive') return null; const e = d(this.scrollSource, this.orientation, this.scrollOffsets, u.get(this).scrollOffsetFns); const t = e[0]; const n = e[e.length - 1]; const i = f(this.scrollSource, this.orientation); if (i < t) return CSS.percent(0); if (i >= n) return CSS.percent(100); const r = (function (e, t) { let n; for (n = t.length - 2; n >= 0 && !(t[n] <= e && e < t[n + 1]); n--) ;const i = t[n]; return (n + (e - i) / (t[n + 1] - i)) * (1 / (t.length - 1)) }(i, e)); return CSS.percent(100 * r) } }, { key: '__polyfill', get: function () { return !0 } }]), e }()); const T = window.Element.prototype.animate; const S = window.Animation; const k = (function () { function e () { const e = this; this.state = 'pending', this.nativeResolve = this.nativeReject = null, this.promise = new Promise(function (t, n) { e.nativeResolve = t, e.nativeReject = n }) } const t = e.prototype; return t.resolve = function (e) { this.state = 'resolved', this.nativeResolve(e) }, t.reject = function (e) { this.state = 'rejected', this.promise.catch(function () {}), this.nativeReject(e) }, e }()); function w (e) { e.readyPromise = new k(), requestAnimationFrame(function () { e.timeline.currentTime !== null && D(e) }) } function b () { return new DOMException('The user aborted a request', 'AbortError') } function P (e, t) { if (t === null) return t; if (typeof t !== 'number') throw new DOMException('Unexpected value: ' + t + '.Cannot convert to CssNumberish', 'InvalidStateError'); const n = U(e); return CSS.percent(n ? 100 * t / n : 0) } function C (e, t) { if (e.timeline) { if (t === null) return t; if (t.unit === 'percent') { const n = U(e); return t.value * n / 100 } throw new DOMException('CSSNumericValue must be a percentage for progress based animations.', 'NotSupportedError') } if (t == null || typeof t === 'number') return t; const i = t.to('ms'); if (convertTime) return i.value; throw new DOMException('CSSNumericValue must be either a number or a time value for time based animations.', 'InvalidStateError') } function E (e) { if (e.finishedPromise && e.finishedPromise.state == 'pending' && e.proxy.playState == 'finished') { e.finishedPromise.resolve(e.proxy), e.animation.pause(); const t = new CustomEvent('finish', { detail: { currentTime: e.proxy.currentTime, timelineTime: e.proxy.timeline.currentTime } }); Object.defineProperty(t, 'currentTime', { get: function () { return this.detail.currentTime } }), Object.defineProperty(t, 'timelineTime', { get: function () { return this.detail.timelineTime } }), requestAnimationFrame(function () { queueMicrotask(function () { e.animation.dispatchEvent(t) }) }) } } function R (e) { return e.pendingPlaybackRate !== null ? e.pendingPlaybackRate : e.animation.playbackRate } function x (e) { e.pendingPlaybackRate !== null && (e.animation.playbackRate = e.pendingPlaybackRate, e.pendingPlaybackRate = null) } function O (e) { if (!e.timeline) return null; const t = C(e, e.timeline.currentTime); if (t === null) return null; if (e.startTime === null) return null; let n = (t - e.startTime) * e.animation.playbackRate; return n == -0 && (n = 0), n } function M (e, t) { if (!e.timeline) return null; const n = C(e, e.timeline.currentTime); return n == null ? null : n - t / e.animation.playbackRate } function I (e, t, n) { if (e.timeline) { const i = t ? C(e, e.proxy.currentTime) : O(e); if (i && e.startTime != null && !e.proxy.pending) { const r = R(e); const a = U(e); let o = e.previousCurrentTime; r > 0 && i >= a ? ((o === null || o < a) && (o = a), e.holdTime = t ? i : o) : r < 0 && i <= 0 ? ((o == null || o > 0) && (o = 0), e.holdTime = t ? i : o) : r != 0 && (t && e.holdTime !== null && (e.startTime = M(e, e.holdTime)), e.holdTime = null) }j(e), e.previousCurrentTime = C(e, e.proxy.currentTime), e.proxy.playState == 'finished' ? (e.finishedPromise || (e.finishedPromise = new k()), e.finishedPromise.state == 'pending' && (n ? E(e) : Promise.resolve().then(function () { E(e) }))) : (e.finishedPromise && e.finishedPromise.state == 'resolved' && (e.finishedPromise = new k()), e.animation.playState != 'paused' && e.animation.pause()) } } function U (e) { const t = (function (e) { const t = e.proxy.effect.getTiming(); return e.normalizedTiming || t }(e)); return Math.max(0, t.delay + t.endDelay + t.iterations * t.duration) } function j (e) { if (e.timeline) if (e.startTime !== null) { const t = C(e, e.timeline.currentTime); e.animation.currentTime = (t - e.startTime) * e.animation.playbackRate } else e.holdTime !== null && (e.animation.currentTime = e.holdTime) } function V (e, t) { if (e.timeline) { const n = e.proxy.playState == 'paused' && e.proxy.pending; let i = !1; let r = null; let a = C(e, e.proxy.currentTime); e.resetCurrentTimeOnResume && (a = null, e.resetCurrentTimeOnResume = !1); const o = R(e); const l = U(e); if (o > 0 && t && (a == null || a < 0 || a >= l)) r = 0; else if (o < 0 && t && (a == null || a <= 0 || a > l)) { if (Infinity == l) return void e.animation.play(); r = l } else o == 0 && a == null && (r = 0); r != null && (e.startTime = r, e.holdTime = null, x(e)), v(e.timeline, e.animation, A.bind(e.proxy)), e.holdTime && (e.startTime = null), e.pendingTask && (e.pendingTask = null, i = !0), (e.holdTime !== null || r !== null || n || e.pendingPlaybackRate !== null) && (e.readyPromise && !i && (e.readyPromise = null), j(e), e.readyPromise || w(e), e.pendingTask = 'play', I(e, !1, !1)) } } function A (e) { const t = z.get(this); if (e != null) { t.pendingTask && D(t); const n = this.playState; if (n == 'running' || n == 'finished') { const i = C(t, e); t.animation.currentTime = (i - C(t, this.startTime)) * this.playbackRate, n == 'finished' && R(t) != 0 && (t.holdTime = null), I(t, !1, !1) } } else t.animation.playState != 'idle' && t.animation.cancel() } function D (e) { e.pendingTask == 'pause' ? (function (e) { const t = C(e, e.timeline.currentTime); e.startTime != null && e.holdTime == null && (e.holdTime = (t - e.startTime) * e.animation.playbackRate), x(e), e.startTime = null, e.readyPromise.resolve(e.proxy), I(e, !1, !1), j(e), e.pendingTask = null }(e)) : e.pendingTask == 'play' && (function (e) { const t = C(e, e.timeline.currentTime); if (e.holdTime != null) x(e), e.animation.playbackRate == 0 ? e.startTime = t : (e.startTime = t - e.holdTime / e.animation.playbackRate, e.holdTime = null); else if (e.startTime !== null && e.pendingPlaybackRate !== null) { const n = (t - e.startTime) * e.animation.playbackRate; x(e); const i = e.animation.playbackRate; i == 0 ? (e.holdTime = null, e.startTime = t) : e.startTime = t - n / i }e.readyPromise && e.readyPromise.state == 'pending' && e.readyPromise.resolve(e.proxy), I(e, !1, !1), j(e), e.pendingTask = null }(e)) } var z = new WeakMap(); const W = (function () { function e (e, t) { const n = e instanceof S ? e : new S(e, r); const i = t instanceof y; var r = i ? void 0 : t; z.set(this, { animation: n, timeline: i ? t : void 0, playState: i ? 'idle' : null, readyPromise: null, finishedPromise: null, startTime: null, holdTime: null, previousCurrentTime: null, resetCurrentTimeOnResume: !1, pendingPlaybackRate: null, pendingTask: null, specifiedTiming: null, normalizedTiming: null, effect: null, proxy: this }) } const n = e.prototype; return n.finish = function () { const e = z.get(this); if (e.timeline) { const t = R(e); const n = U(e); if (t == 0) throw new DOMException('Cannot finish Animation with a playbackRate of 0.', 'InvalidStateError'); if (t > 0 && Infinity == n) throw new DOMException('Cannot finish Animation with an infinite target effect end.', 'InvalidStateError'); x(e); const i = t < 0 ? 0 : n; this.currentTime = P(e, i); const r = C(e, e.timeline.currentTime); e.startTime === null && r !== null && (e.startTime = r - i / e.animation.playbackRate), e.pendingTask == 'pause' && e.startTime !== null && (e.holdTime = null, e.pendingTask = null, e.readyPromise.resolve(this)), e.pendingTask == 'play' && e.startTime !== null && (e.pendingTask = null, e.readyPromise.resolve(this)), I(e, !0, !0) } else e.animation.finish() }, n.play = function () { const e = z.get(this); e.timeline ? V(e, !0) : e.animation.play() }, n.pause = function () { const e = z.get(this); if (e.timeline) { if (this.playState != 'paused') { let t = null; const n = e.animation.playbackRate; const i = U(e); if (e.animation.currentTime === null) if (n >= 0) t = 0; else { if (Infinity == i) return void e.animation.pause(); t = i }t !== null && (e.startTime = t), e.pendingTask == 'play' ? e.pendingTask = null : e.readyPromise = null, e.readyPromise || w(e), e.pendingTask = 'pause' } } else e.animation.pause() }, n.reverse = function () { const e = z.get(this); const t = R(e); const n = e.resetCurrentTimeOnResume ? null : C(e, this.currentTime); const i = Infinity == U(e); const r = t != 0 && (t < 0 || n > 0 || !i); if (!e.timeline || !r) return r && (e.pendingPlaybackRate = -R(e)), void e.animation.reverse(); if (e.timeline.phase == 'inactive') throw new DOMException('Cannot reverse an animation with no active timeline', 'InvalidStateError'); this.updatePlaybackRate(-t), V(e, !0) }, n.updatePlaybackRate = function (e) { const t = z.get(this); if (t.pendingPlaybackRate = e, t.timeline) { if (!t.readyPromise || t.readyPromise.state != 'pending') switch (this.playState) { case 'idle':case 'paused':x(t); break; case 'finished':var n = C(t, t.timeline.currentTime); var i = n !== null ? (n - t.startTime) * t.animation.playbackRate : null; t.startTime = e == 0 ? n : n != null && i != null ? (n - i) / e : null, x(t), I(t, !1, !1), j(t); break; default:V(t, !1) } } else t.animation.updatePlaybackRate(e) }, n.persist = function () { z.get(this).animation.persist() }, n.cancel = function () { const e = z.get(this); e.timeline ? (this.playState != 'idle' && ((function (e) { e.pendingTask && (e.pendingTask = null, x(e), e.readyPromise.reject(b()), w(e), e.readyPromise.resolve(e.proxy)) }(e)), e.finishedPromise && e.finishedPromise.state == 'pending' && e.finishedPromise.reject(b()), e.finishedPromise = new k(), e.animation.cancel()), e.startTime = null, e.holdTime = null, g(e.timeline, e.animation)) : e.animation.cancel() }, n.addEventListener = function (e, t, n) { z.get(this).animation.addEventListener(e, t, n) }, n.removeEventListener = function (e, t, n) { z.get(this).animation.removeEventListener(e, t, n) }, n.dispatchEvent = function (e) { z.get(this).animation.dispatchEvent(e) }, t(e, [{ key: 'effect', get: function () { const e = z.get(this); return e.timeline ? (e.effect || (e.effect = (function (e) { const t = e.animation.effect; const n = t.updateTiming; const i = { apply: function (n) { t.getTiming(); const i = n.apply(t); if (e.timeline) { i.localTime = P(e, i.localTime), i.endTime = P(e, i.endTime), i.activeDuration = P(e, i.activeDuration); const r = U(e); i.duration = r ? CSS.percent(100 * (i.iterations ? (r - i.delay - i.endDelay) / i.iterations : 0) / r) : CSS.percent(0); const a = e.timeline.phase; const o = i.fill; a == 'before' && o != 'backwards' && o != 'both' && (i.progress = null), a == 'after' && o != 'forwards' && o != 'both' && (i.progress = null), void 0 === e.timeline.currentTime && (i.localTime = null) } return i } }; const r = { apply: function (i, r) { if (e.specifiedTiming) return e.specifiedTiming; e.specifiedTiming = i.apply(t); const a = Object.assign({}, e.specifiedTiming); return a.duration !== null && a.duration !== 'auto' || e.timeline && (a.delay = 0, a.endDelay = 0, a.duration = a.iterations ? (a.iterations ? 1e5 : 0) / a.iterations : 0, n.apply(t, [a])), e.normalizedTiming = a, e.specifiedTiming } }; const a = { apply: function (n, i, r) { if (e.timeline) { const a = r[0]; if (Infinity === a.duration) throw TypeError('Effect duration cannot be Infinity when used with Scroll Timelines'); if (Infinity === a.iterations) throw TypeError('Effect iterations cannot be Infinity when used with Scroll Timelines') }e.specifiedTiming && n.apply(t, [e.specifiedTiming]), n.apply(t, r), e.specifiedTiming = null } }; const o = new Proxy(t, { get: function (e, n) { const i = e[n]; return typeof i === 'function' ? i.bind(t) : i }, set: function (e, t, n) { return e[t] = n, !0 } }); return o.getComputedTiming = new Proxy(t.getComputedTiming, i), o.getTiming = new Proxy(t.getTiming, r), o.updateTiming = new Proxy(t.updateTiming, a), o }(e))), e.effect) : e.animation.effect }, set: function (e) { z.get(this).animation.effect = e, details.effect = null } }, { key: 'timeline', get: function () { const e = z.get(this); return e.timeline || e.animation.timeline }, set: function (e) { const t = this.timeline; if (t != e) { const n = this.playState; const i = this.currentTime; const r = z.get(this); const a = U(r); const o = a > 0 ? C(r, i) / a : 0; const l = t instanceof y; const u = e instanceof y; r.resetCurrentTimeOnResume = !1; const s = this.pending; if (l && g(r.timeline, r.animation), u) { r.timeline = e, x(r); const c = r.animation.playbackRate >= 0 ? 0 : U(r); switch (n) { case 'running':case 'finished':r.startTime = c, v(r.timeline, r.animation, A.bind(this)); break; case 'paused':r.resetCurrentTimeOnResume = !0, r.startTime = null, r.holdTime = C(r, CSS.percent(100 * o)); break; default:r.holdTime = null, r.startTime = null } return s && (r.readyPromise && r.readyPromise.state != 'resolved' || w(r), r.pendingTask = n == 'paused' ? 'pause' : 'play'), r.startTime !== null && (r.holdTime = null), void I(r, !1, !1) } if (r.animation.timeline != e) throw TypeError('Unsupported timeline: ' + e); if (g(r.timeline, r.animation), r.timeline = null, l) switch (i !== null && (r.animation.currentTime = o * U(r)), n) { case 'paused':r.animation.pause(); break; case 'running':case 'finished':r.animation.play() } } } }, { key: 'startTime', get: function () { const e = z.get(this); return e.timeline ? P(e, e.startTime) : e.animation.startTime }, set: function (e) { const t = z.get(this); if (e = C(t, e), t.timeline) { C(t, t.timeline.currentTime) == null && t.startTime != null && (t.holdTime = null, j(t)); const n = C(t, this.currentTime); x(t), t.startTime = e, t.resetCurrentTimeOnResume = !1, t.holdTime = t.startTime !== null && t.animation.playbackRate != 0 ? null : n, t.pendingTask && (t.pendingTask = null, t.readyPromise.resolve(this)), I(t, !0, !1), j(t) } else t.animation.startTime = e } }, { key: 'currentTime', get: function () { const e = z.get(this); return e.timeline ? P(e, e.holdTime != null ? e.holdTime : O(e)) : e.animation.currentTime }, set: function (e) { const t = z.get(this); if (e = C(t, e), t.timeline && e != null) { const n = t.timeline.phase; t.holdTime !== null || t.startTime === null || n == 'inactive' || t.animation.playbackRate == 0 ? t.holdTime = e : t.startTime = M(t, e), t.resetCurrentTimeOnResume = !1, n == 'inactive' && (t.startTime = null), t.previousCurrentTime = null, t.pendingTask == 'pause' && (t.holdTime = e, x(t), t.startTime = null, t.pendingTask = null, t.readyPromise.resolve(this)), I(t, !0, !1) } else t.animation.currentTime = e } }, { key: 'playbackRate', get: function () { return z.get(this).animation.playbackRate }, set: function (e) { const t = z.get(this); if (t.timeline) { t.pendingPlaybackRate = null; const n = this.currentTime; t.animation.playbackRate = e, n !== null && (this.currentTime = n) } else t.animation.playbackRate = e } }, { key: 'playState', get: function () { const e = z.get(this); if (!e.timeline) return e.animation.playState; const t = C(e, this.currentTime); if (t === null && e.startTime === null && e.pendingTask == null) return 'idle'; if (e.pendingTask == 'pause' || e.startTime === null && e.pendingTask != 'play') return 'paused'; if (t != null) { if (e.animation.playbackRate > 0 && t >= U(e)) return 'finished'; if (e.animation.playbackRate < 0 && t <= 0) return 'finished' } return 'running' } }, { key: 'replaceState', get: function () { return z.get(this).animation.pending } }, { key: 'pending', get: function () { const e = z.get(this); return e.timeline ? !!e.readyPromise && e.readyPromise.state == 'pending' : e.animation.pending } }, { key: 'id', get: function () { return z.get(this).animation.id } }, { key: 'onfinish', get: function () { return z.get(this).animation.onfinish }, set: function (e) { z.get(this).animation.onfinish = e } }, { key: 'oncancel', get: function () { return z.get(this).animation.oncancel }, set: function (e) { z.get(this).animation.oncancel = e } }, { key: 'onremove', get: function () { return z.get(this).animation.onremove }, set: function (e) { z.get(this).animation.onremove = e } }, { key: 'finished', get: function () { const e = z.get(this); return e.timeline ? (e.finishedPromise || (e.finishedPromise = new k()), e.finishedPromise.promise) : e.animation.finished } }, { key: 'ready', get: function () { const e = z.get(this); return e.timeline ? (e.readyPromise || (e.readyPromise = new k(), e.readyPromise.resolve(this)), e.readyPromise.promise) : e.animation.ready } }]), e }()); const L = new WeakMap(); const F = [[[0, 1, 2, 3]], [[0, 2], [1, 3]], [[0], [1, 3], [2]], [[0], [1], [2], [3]]]; const H = (function () { function e (e) { L.set(this, { target: null, edge: 'start', threshold: 0, rootMargin: [[0, 'px'], [0, 'px'], [0, 'px'], [0, 'px']] }), this.target = e.target, this.edge = e.edge || 'start', this.threshold = e.threshold || 0, this.rootMargin = e.rootMargin || '0px 0px 0px 0px', this.clamp = e.clamp || !1 } return t(e, [{ key: 'target', get: function () { return L.get(this).target }, set: function (e) { if (!(e instanceof Element)) throw L.get(this).target = null, Error('Intersection target must be an element.'); L.get(this).target = e } }, { key: 'edge', get: function () { return L.get(this).edge }, set: function (e) { ['start', 'end'].indexOf(e) != -1 && (L.get(this).edge = e) } }, { key: 'threshold', get: function () { return L.get(this).threshold }, set: function (e) { const t = parseFloat(e); if (t != t) throw TypeError('Invalid threshold.'); if (t < 0 || t > 1) throw TypeError('threshold must be in the range [0, 1]'); L.get(this).threshold = t } }, { key: 'rootMargin', get: function () { return L.get(this).rootMargin.map(function (e) { return e.join('') }).join(' ') }, set: function (e) { const t = e.split(/ +/); if (t.length < 1 || t.length > 4) throw TypeError('rootMargin must contain between 1 and 4 length components'); for (var n = [[], [], [], []], i = 0; i < t.length; i++) { const r = o(t[i], !0); if (!r) throw TypeError('Unrecognized rootMargin length'); for (let a = F[t.length - 1][i], l = 0; l < a.length; l++) n[a[l]] = [parseFloat(r.value), r.unit] }L.get(this).rootMargin = n } }, { key: 'clamp', set: function (e) { L.get(this).clamp = !!e } }]), e }()); if (s.push({ parse: function (e) { if (e.target) return new H(e) }, evaluate: function (e, t, n, i) { t == 'block' ? t = 'vertical' : t == 'inline' && (t = 'horizontal'); for (var r, a = e == document.scrollingElement ? { left: 0, right: e.clientWidth, top: 0, bottom: e.clientHeight, width: e.clientWidth, height: e.clientHeight } : e.getBoundingClientRect(), o = L.get(n).rootMargin, l = [], u = 0; u < 4; u++) l.push((r = o[u])[1] == 'percent' ? r[0] * (u % 2 == 0 ? a.height : a.width) / 100 : r[0]); const s = a.left - l[3]; const c = a.right - a.left + l[3] + l[1]; const m = a.top - l[0]; const f = a.bottom - a.top + l[0] + l[2]; const h = L.get(n).clamp; const p = n.target.getBoundingClientRect(); let d = n.threshold; if (n.edge == 'start' && (d = 1 - d), t == 'vertical') { const g = p.top + p.height * d - m + e.scrollTop; return h ? n.edge == 'end' ? Math.max(0, g - f) : Math.min(g, e.scrollHeight - f) : n.edge == 'end' ? g - f : g } const v = p.left + p.width * d - s + e.scrollLeft; return h ? n.edge == 'end' ? Math.max(0, v - c) : Math.min(v, e.scrollWidth - c) : n.edge == 'end' ? v - c : v } }), !Reflect.defineProperty(window, 'ScrollTimeline', { value: y })) throw Error('Error installing ScrollTimeline polyfill: could not attach ScrollTimeline to window'); if (!Reflect.defineProperty(Element.prototype, 'animate', { value: function (e, t) { const n = t.timeline; n instanceof y && delete t.timeline; const i = T.apply(this, [e, t]); const r = new W(i, n); return n instanceof y && (i.pause(), r.play()), r } })) throw Error("Error installing ScrollTimeline polyfill: could not attach WAAPI's animate to DOM Element"); if (!Reflect.defineProperty(window, 'Animation', { value: W })) throw Error('Error installing Animation constructor.') }())
